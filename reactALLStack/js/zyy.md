# 1 作用域

> *作者:huangteng*

### 1.1 编译原理
***
javaScript的编译过程极其复杂，我们抽离出三个核心的步骤：

* 分词(Tokenizing/Relaxing)
> 就是把var a = 2;分解成var、a、=、2、;等词法单元(Token)
* 语法解析(Parsing)
> 将Token连接起来构造抽象语法树(AST)
* 生成代码
> 将 AST 转换为可执行代码的过程称被称为代码生成        


### 1.2 LHS和RHS
***
我们声明的变量给它赋值，如var a = 2;，这一过程在js底层会经历复杂的操作，其中我们需要了解的就是LHS查询和RHS查询。

LHS，顾名思义，左查询，左指的是等号左边，目的是为了找到赋值的对象，实际是去查找变量的容器本身。

``
var a  =  2 ;
``
这里引擎对a进行LHS查询，目的是为了赋值给它

RHS，目的是为了获取它的值，如:

```
if(a){
    ...
}
```

这里引擎对a进行RHS查询，是为了获取它的值。


### 1.3 作用域嵌套
***
首先要知道作用域是什么?

> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）

作用域可以发生嵌套，这在我们的工作中很常见，关键是我们要清楚作用域嵌套时LHS和RHS查询是由里向外一层一层进行查找，直到最外层的，如果直到在最外层作用域(很可能是全局作用域)都还没有找到的话，在严格模式下("use strict")LHS和RHS查找都会报错，ReferenceError，在非严格模式下LHS查询失败会在全局作用域声明一个新的变量。

### 1.4 词法作用域
***
区别于动态作用域，词法作用域取决于你的代码写在哪里。比如下面这个列子就有三层作用域。

```
var a;
function foo(){
    function bar(){
        a = 2;
    }
}
```

作用域嵌套导致对a进行LHS查找会一层一层，从里向外，直到全局。
注意：当引擎找到变量时即停止，这个时候如果外层也有该同名变量，会被屏蔽。
这样的屏蔽机制在原型链查找时也同样存在

> tips
> *全局变量会自动成为全局对象的属性，所以可以通过window.a来访问全局变量*

### 1.5 eval与with
***
在项目中发现了eval的使用，但是为什么一直不建议使用他们呢？

eval和with都是可以欺骗作用域的。

首先，eval()的作用就是让它包裹的str可以就像是你写在eval(str)所在位置的代码一样。eval(..) 通常被用来执行动态创建的代码

自然它可以欺骗作用域：
```
function foo(str,b){
    eval(str);
    console.log(a,b)
}

var a = 2;
foo("var a = 3",2);// 3,2
```
这段代码在严格模式下就会报错ReferenceError

与eval()这样的功能相似的还有new Function()、setTimeout()...都是不安全的。

with:

with的作用有点和oracle中with的用法异曲同工，都是为了省事儿。js中with主要用于减少对对象的引用。比如

```
var obj = {
    a : 2,
    b : 3,
    c : 4
}

一般我们这样赋值
obj.a = 5;
obj.b = 6;
obj.c = 7;

用with
with (obj) {
    a = 5;
    b = 6;
    c = 7;
}
```

with用起来是不是很方便，但是！背后的坑也大
我们看看下面的代码:
```
function foo(obj){
 with(obj){
	 a = 2
 }
}
var o1 = {
	a : 3
}
var o2 = {
	b : 3
}
foo(o1);
console.log(o1.a); //2
foo(o2);
console.log(o2.a);//undefined
console.log(a)//2 <--污染了全局
```
我们来分析一下，为什么a变成了全局的，因为o2没有a属性，LHS查找失败，在非严格模式下会在全局创建一个新的a变量被赋值为2.

### 1.6 函数作用域和块作用域
***
一般我们都认为创建函数时候会创建其作用域，也就是花括号包裹那块区域，但是这样并不准确。

函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。在函数作用域内部的属性外界是不能访问的。原因是LHS和RHS查找是由里向外逐层查找的。


IIFE(立即执行函数表达式)
```
(function(){
    window.getData = function(){
        ....
    }
})(window)
```
IIFE拥有自己的作用域，可以避免污染全局，因此很多框架外层结构采用了IIFE，比如我们熟悉
的jquery框架外层结构如上代码所示。


但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块（通常指 { .. } 内部）。

对于块作用域，ES3时代最典型的列子是try catch结构，在ES6时代引入了let，静态块等。
```
for(var i = 0 ; i<10;i++){
    console.log(i)
}
console.log(i)

和

for(let i = 0 ; i<10;i++){
    console.log(i)
}
console.log(i)

静态块
{
    foo()
}

```

const,也是建立了块作用域。表示常量。
其实现的机制是变量的writeable属性为false

### 1.7  提升
***
引擎在编译过程中会对变量和函数的声明进行提升。提升到代码最顶端的感觉。先有蛋（声明）后有鸡（赋值） 举列说明:

```
a = 2;
var a;
console.log(a);//2
```

提升发生在每一个作用域中，对于函数来说函数声明会被提升，函数表达式不会。区别函数生命和函数表达式的最直接的办法就是看function左边有没有别的修饰

```
函数声明
foo()//可以执行
function foo(){...}


函数表达式
foo();//TypeError
var foo = function(){...}
```
函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量。

```
foo(); // 1 
 
var foo; 
 
function foo() {     console.log( 1 ); } 
 
foo = function() {     console.log( 2 ); };
```
*注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽 略了），因为函数声明会被提升到普通变量之前。*

### 1.8  闭包
***
对于闭包的恐惧是没有真正理解它，总觉得他是晦涩难懂的不可触碰，但是闭包却是处处可见，不用刻意去制造。

```
function foo() {     
    var a = 2; 
 
    function bar() {  
        console.log( a );   
    } 
    return bar; 
}
 
var baz = foo(); 
 
baz(); // 2 —— 这就是闭包的效果。

```
我们来分析一下上面的代码:
 * 函数 bar() 的词法作用域能够访问 foo() 的内部作用域
 * 然后我们将 bar() 函数本身当作 一个值类型进行传递
 * bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方 执行。
 * 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用


**当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包**

*所有的回调函数都是闭包*

> 怎么写出闭包？

> 看看我曾经和同事讨论过的一个demo

```
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );   
    }, i*1000 );
}
```
上面的demo在你认识中应该输出什么?


实际输出的是:每隔一秒输出5次6

要想得到我们心中的答案，我们可以使用闭包

```
for(var i = 1;i<=5;i++){
    (function(j){
        setTimeout( function timer() {
            console.log( j );   
        }, j*1000 );
    })(i)
}
```

在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。


还可以使用let实现


```
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );   
    }, i*1000 );
}
```
 let 声明有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

 




